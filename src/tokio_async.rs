// // #[macro_use] extern crate rocket;

// // #[get("/")]
// // fn index() -> &'static str {
// //     "Hello, world!"
// // }

// // #[launch]
// // fn rocket() -> _ {
// //     rocket::build().mount("/", routes![index])
// // }

// // fn main() {
// //     println!("Hello, world!");
// // }
// #[macro_use] extern crate diesel;
// extern crate dotenv;

// use diesel::prelude::*;
// use diesel::pg::PgConnection;
// use diesel::Insertable;
// use diesel::Queryable;
// use diesel::table;
// use dotenv::dotenv;
// use std::env;

// #[derive(Queryable, Insertable)]
// #[table_name = "books"]
// struct Book {
//     id: i32,
//     title: String,
//     author: String,
//     status: String,
// }

// pub fn establish_connection() -> PgConnection {
//     dotenv().ok();

//     let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
//     PgConnection::establish(&database_url)
//         .expect(&format!("Error connecting to {}", database_url))
// }

// // Function to insert a new book into the database
// pub fn insert_book(title: &str, author: &str, status: &str) {
//     let connection = establish_connection();
    
//     let new_book = Book {
//         id: 0, // id will be auto-generated by the database
//         title: title.to_string(),
//         author: author.to_string(),
//         status: status.to_string(),
//     };

//     // Use Diesel to insert the book
//     diesel::insert_into(books::table)
//         .values(&new_book)
//         .execute(&connection)
//         .expect("Error inserting new book");
// }

// // Function to fetch all books from the database
// pub fn fetch_books() -> Vec<Book> {
//     let connection = establish_connection();
    
//     // Use Diesel to fetch all books
//     books::table.load::<Book>(&connection).expect("Error loading books")
// }

// #[tokio::main]
// async fn main() {
//     // Insert a new book into the database
//     insert_book("The Rust Book", "Jane Doe", "Available");

//     // Fetch and display all books
//     let books = fetch_books();
//     for book in books {
//         println!("Book Title: {}, Author: {}, Status: {}", book.title, book.author, book.status);
//     }
// }

// // use rocket::serde::{Serialize, json::Json};

// // #[derive(Serialize)]
// // struct Message {
// //     message: String,
// // }

// // #[get("/json")]
// // fn json_response() -> Json<Message> {
// //     Json(Message {
// //         message: "Hello, JSON!".to_string(),
// //     })
// // }
// // #[get("/")]
// // fn index() -> &'static str {
// //     "Hello, world!"
// // }
// // #[derive(Serialize)]
// // struct Greeting {
// //     message: String,
// // }

// // #[get("/hello/<name>")]
// // fn hello(name: &str) -> Json<Greeting> {
// //     Json(Greeting {
// //         message: format!("Hello, {}!", name),
// //     })
// // }
// // // #[get("/hello/<name>")]
// // // fn hello(name: String) -> String {
// // //     format!("Hello, {}!", name)
// // // }
// // #[launch]
// // fn rocket() -> _ {
// //     rocket::build().mount("/", routes![index,json_response, hello])
// // }

// // // why #[macro_use] extern crate rocket; instead of use rocket
